# Nand2Tetris Projects 6-12 Report
**Student:** 林順義 (111310521)
**Date:** 2025/12/16

---

## ⚠️ 誠實聲明 (Declaration of Originality)

**總結 (Summary):**
本專案 (Project 6 - Project 12) 的所有程式碼主要由 AI 生成。我理解整個軟體架構的運作流程 (Workflow)，但在具體的 Backend 實作細節 (如 Compiler 的 Python 邏輯或 OS 演算法細節) 是依靠 AI 協助完成。

**AI 對話紀錄 (AI Chat Logs):**
* [https://gemini.google.com/share/7661a23e80f3]

---

## 詳細章節說明 (Module Breakdown & Status)

### Project 6: The Assembler
* **來源 (Source):** AI 生成 (AI Generated).
* **理解程度 (Understanding):** 我理解 Assembler 如何將 `.asm` 符號翻譯成二進制 `.hack`。我知道 Symbol Table 用來處理變數和跳轉標籤 (Labels)，也理解 A-instruction 與 C-instruction 的格式區別。

### Project 7 & 8: Virtual Machine Translator
* **來源 (Source):** AI 生成 (AI Generated).
* **理解程度 (Understanding):** 我理解 VM 翻譯的邏輯。我知道 Stack arithmetic (push/pop, add, sub) 是如何運作的，以及 Memory Segments (local, argument, this, that) 是如何映射到 Hack RAM 的。

### Project 9: High-Level Language Application (Catch Fruit)
* **來源 (Source):** AI 協助修改範例 (AI Assisted / Modified).
* **理解程度 (Understanding):** 這是用 Jack 語言寫的小遊戲。我理解 Jack 的語法結構以及如何呼叫標準庫 (如 Output, Screen)。

### Project 10: Compiler I (Syntax Analysis)
* **來源 (Source):** AI 生成 (AI Generated).
* **理解程度 (Understanding):** 我理解 Compiler 前端的工作流程：先透過 Tokenizer 將原始碼切分成 Tokens，再透過 Parser 根據語法規則建立 XML 結構 (Parse Tree)。

### Project 11: Compiler II (Code Generation)
* **來源 (Source):** AI 生成 (AI Generated).
* **理解程度 (Understanding):** 我理解 Backend 的目標是輸出 VM Code。我知道 Symbol Table 需要區分 Class scope 和 Subroutine scope，但具體的遞迴生成邏輯是由 AI 完成的。

### Project 12: The Operating System
* **來源 (Source):** AI 生成 (AI Generated).
* **理解程度 (Understanding):** 雖然老師指示可以閱讀解答，但我嘗試使用 AI 協助完成了 OS 的實作。我理解這些 Class 是為了彌補硬體功能的不足 (例如用軟體實作乘法、除法、以及記憶體管理)。

---

## Software Stack Overview (My Learning Notes)

雖然程式碼主要由 AI 生成，但我整理了以下我對 Nand2Tetris Part II 軟體層級的理解：

The software hierarchy transforms high-level abstractions into executable binary:
1.  **High-Level Language (Jack):** Object-oriented language similar to Java.
2.  **Virtual Machine (VM):** Abstracts the hardware. The Compiler generates VM code, which is stack-based.
3.  **Assembly Language:** Symbolic representation (`@value`, `D=M+1`). The VM Translator generates this.
4.  **Binary Code:** The final 16-bit instructions. The Assembler generates this.

### Tools Used
* **Implementation Language:** Python & Jack (Code generated by AI).
* **Verification:** Used the provided TextComparer and CPU Emulator to verify that the AI-generated code produces the correct output.
